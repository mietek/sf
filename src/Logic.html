<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Logic: Logic in Coq</title>
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Logic<span class="subtitle">Logic in Coq</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Tactics.html#"><span class="id" type="library">Tactics</span></a>.<br/>

<br/>
</div>

<div class="doc">
In previous chapters, we have seen many examples of factual
    claims (<i>propositions</i>) and ways of presenting evidence of their
    truth (<i>proofs</i>).  In particular, we have worked extensively with
    <i>equality propositions</i> of the form <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span>, with
    implications (<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>), and with quantified propositions (<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>
    <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span>).  In this chapter, we will see how Coq can be used to carry
    out other familiar forms of logical reasoning.

<div class="paragraph"> </div>

    Before diving into details, let's talk a bit about the status of
    mathematical statements in Coq.  Recall that Coq is a <i>typed</i>
    language, which means that every sensible expression in its world
    has an associated type.  Logical claims are no exception: any
    statement we might try to prove in Coq has a type, namely <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>,
    the type of <i>propositions</i>.  We can see this with the <span class="inlinecode"><span class="id" type="keyword">Check</span></span>
    command: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> 3 = 3.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Note that <i>all</i> syntactically well-formed propositions have type
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> in Coq, regardless of whether they are true or not.

<div class="paragraph"> </div>

    Simply <i>being</i> a proposition is one thing; being <i>provable</i> is
    something else! 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 2.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> 3 = 4.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Indeed, propositions don't just have types: they are <i>first-class
    objects</i> that can be manipulated in the same ways as the other
    entities in Coq's world.  So far, we've seen one primary place
    that propositions can appear: in <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> (and <span class="inlinecode"><span class="id" type="keyword">Lemma</span></span> and
    <span class="inlinecode"><span class="id" type="keyword">Example</span></span>) declarations. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_2_2_is_4"><span class="id" type="lemma">plus_2_2_is_4</span></a> :<br/>
&nbsp;&nbsp;2 + 2 = 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
But propositions can be used in many other ways.  For example, we
    can give a name to a proposition using a <span class="inlinecode"><span class="id" type="keyword">Definition</span></span>, just as we
    have given names to expressions of other sorts. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="plus_fact"><span class="id" type="definition">plus_fact</span></a> : <span class="id" type="keyword">Prop</span> := 2 + 2 = 4.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#plus_fact"><span class="id" type="definition">plus_fact</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;plus_fact&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
We can later use this name in any situation where a proposition is
    expected &mdash; for example, as the claim in a <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> declaration. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_fact_is_true"><span class="id" type="lemma">plus_fact_is_true</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#plus_fact"><span class="id" type="definition">plus_fact</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can also write <i>parameterized</i> propositions &mdash; that is,
    functions that take arguments of some type and return a
    proposition. 
<div class="paragraph"> </div>

 For instance, the following function takes a number
    and returns a proposition asserting that this number is equal to
    three: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="is_three"><span class="id" type="definition">is_three</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 3.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#is_three"><span class="id" type="definition">is_three</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
In Coq, functions that return propositions are said to define
    <i>properties</i> of their arguments.

<div class="paragraph"> </div>

    For instance, here's a (polymorphic) property defining the
    familiar notion of an <i>injective function</i>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="injective"><span class="id" type="definition">injective</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span>} (<span class="id" type="var">f</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#B"><span class="id" type="variable">B</span></a>) :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> = <a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Logic.html#y"><span class="id" type="variable">y</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> = <a class="idref" href="Logic.html#y"><span class="id" type="variable">y</span></a>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="succ_inj"><span class="id" type="lemma">succ_inj</span></a> : <a class="idref" href="Logic.html#injective"><span class="id" type="definition">injective</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The equality operator <span class="inlinecode">=</span> is also a function that returns a
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    The expression <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> is syntactic sugar for <span class="inlinecode"><span class="id" type="var">eq</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>, defined
    using Coq's <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> mechanism. Because <span class="inlinecode"><span class="id" type="var">eq</span></span> can be used with
    elements of any type, it is also polymorphic: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> @<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#eq"><span class="id" type="inductive">eq</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
(Notice that we wrote <span class="inlinecode">@<span class="id" type="var">eq</span></span> instead of <span class="inlinecode"><span class="id" type="var">eq</span></span>: The type
    argument <span class="inlinecode"><span class="id" type="var">A</span></span> to <span class="inlinecode"><span class="id" type="var">eq</span></span> is declared as implicit, so we need to turn
    off implicit arguments to see the full type of <span class="inlinecode"><span class="id" type="var">eq</span></span>.) 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab155"></a><h1 class="section">Logical Connectives</h1>

<div class="paragraph"> </div>

<a name="lab156"></a><h2 class="section">Conjunction</h2>

<div class="paragraph"> </div>

 The <i>conjunction</i> (or <i>logical and</i>) of propositions <span class="inlinecode"><span class="id" type="var">A</span></span> and <span class="inlinecode"><span class="id" type="var">B</span></span>
    is written <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>, representing the claim that both <span class="inlinecode"><span class="id" type="var">A</span></span> and <span class="inlinecode"><span class="id" type="var">B</span></span>
    are true. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="and_example"><span class="id" type="definition">and_example</span></a> : 3 + 4 = 7 <span style="font-family: arial;">&and;</span> 2 * 2 = 4.<br/>

<br/>
</div>

<div class="doc">
To prove a conjunction, use the <span class="inlinecode"><span class="id" type="tactic">split</span></span> tactic.  It will generate
    two subgoals, one for each part of the statement: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;3&nbsp;+&nbsp;4&nbsp;=&nbsp;7&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
For any propositions <span class="inlinecode"><span class="id" type="var">A</span></span> and <span class="inlinecode"><span class="id" type="var">B</span></span>, if we assume that <span class="inlinecode"><span class="id" type="var">A</span></span> is true
    and we assume that <span class="inlinecode"><span class="id" type="var">B</span></span> is true, we can conclude that <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> is
    also true. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="and_intro"><span class="id" type="lemma">and_intro</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>, <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#B"><span class="id" type="variable">B</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#B"><span class="id" type="variable">B</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">HA</span> <span class="id" type="var">HB</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">HB</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Since applying a theorem with hypotheses to some goal has the
    effect of generating as many subgoals as there are hypotheses for
    that theorem, we can apply <span class="inlinecode"><span class="id" type="var">and_intro</span></span> to achieve the same effect
    as <span class="inlinecode"><span class="id" type="tactic">split</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="and_example'"><span class="id" type="definition">and_example'</span></a> : 3 + 4 = 7 <span style="font-family: arial;">&and;</span> 2 * 2 = 4.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#and_intro"><span class="id" type="lemma">and_intro</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;3&nbsp;+&nbsp;4&nbsp;=&nbsp;7&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab157"></a><h4 class="section">Exercise: 2 stars (and_exercise)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <a name="and_exercise"><span class="id" type="definition">and_exercise</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

 So much for proving conjunctive statements.  To go in the other
    direction &mdash; i.e., to <i>use</i> a conjunctive hypothesis to help prove
    something else &mdash; we employ the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> tactic.

<div class="paragraph"> </div>

    If the proof context contains a hypothesis <span class="inlinecode"><span class="id" type="var">H</span></span> of the form 
    <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>, writing <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[<span class="id" type="var">HA</span></span> <span class="inlinecode"><span class="id" type="var">HB</span>]</span> will remove <span class="inlinecode"><span class="id" type="var">H</span></span> from the
    context and add two new hypotheses: <span class="inlinecode"><span class="id" type="var">HA</span></span>, stating that <span class="inlinecode"><span class="id" type="var">A</span></span> is
    true, and <span class="inlinecode"><span class="id" type="var">HB</span></span>, stating that <span class="inlinecode"><span class="id" type="var">B</span></span> is true.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="and_example2"><span class="id" type="lemma">and_example2</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As usual, we can also destruct <span class="inlinecode"><span class="id" type="var">H</span></span> right when we introduce it,
    instead of introducing and then destructing it: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="and_example2'"><span class="id" type="lemma">and_example2'</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
You may wonder why we bothered packing the two hypotheses <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>
    and <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> into a single conjunction, since we could have also
    stated the theorem with two separate premises: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="and_example2''"><span class="id" type="lemma">and_example2''</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
For this theorem, both formulations are fine.  But it's important
    to understand how to work with conjunctive hypotheses because
    conjunctions often arise from intermediate steps in proofs,
    especially in bigger developments.  Here's a simple example: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="and_example3"><span class="id" type="lemma">and_example3</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> : <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&and;</span> <span class="id" type="var">m</span> = 0).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#and_exercise"><span class="id" type="axiom">and_exercise</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H'</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Another common situation with conjunctions is that we know 
    <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> but in some context we need just <span class="inlinecode"><span class="id" type="var">A</span></span> (or just <span class="inlinecode"><span class="id" type="var">B</span></span>).  
    The following lemmas are useful in such cases: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="proj1"><span class="id" type="lemma">proj1</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab158"></a><h4 class="section">Exercise: 1 star, optional (proj2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <a name="proj2"><span class="id" type="lemma">proj2</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

 Finally, we sometimes need to rearrange the order of conjunctions
    and/or the grouping of multi-way conjunctions.  The following
    commutativity and associativity theorems are handy in such
    cases. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_commut"><span class="id" type="lemma">and_commut</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;left&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;right&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab159"></a><h4 class="section">Exercise: 2 stars (and_assoc)</h4>
 (In the following proof of associativity, notice how the <i>nested</i>
    intro pattern breaks the hypothesis <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode">(<span class="id" type="var">Q</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">R</span>)</span> down into
    <span class="inlinecode"><span class="id" type="var">HP</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span>, <span class="inlinecode"><span class="id" type="var">HQ</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>, and <span class="inlinecode"><span class="id" type="var">HR</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">R</span></span>.  Finish the proof from
    there.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_assoc"><span class="id" type="lemma">and_assoc</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> (<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> [<span class="id" type="var">HP</span> [<span class="id" type="var">HQ</span> <span class="id" type="var">HR</span>]].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

 By the way, the infix notation <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> is actually just syntactic
    sugar for <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>.  That is, <span class="inlinecode"><span class="id" type="var">and</span></span> is a Coq operator that takes
    two propositions as arguments and yields a proposition. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#and"><span class="id" type="inductive">and</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;and&nbsp;:&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab160"></a><h2 class="section">Disjunction</h2>

<div class="paragraph"> </div>

 Another important connective is the <i>disjunction</i>, or <i>logical or</i>
    of two propositions: <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> is true when either <span class="inlinecode"><span class="id" type="var">A</span></span> or <span class="inlinecode"><span class="id" type="var">B</span></span>
    is.  (Alternatively, we can write <span class="inlinecode"><span class="id" type="var">or</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>, where <span class="inlinecode"><span class="id" type="var">or</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span>
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>.)

<div class="paragraph"> </div>

    To use a disjunctive hypothesis in a proof, we proceed by case
    analysis, which, as for <span class="inlinecode"><span class="id" type="var">nat</span></span> or other data types, can be done
    with <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> or <span class="inlinecode"><span class="id" type="tactic">intros</span></span>.  Here is an example: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="or_example"><span class="id" type="lemma">or_example</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;pattern&nbsp;implicitly&nbsp;does&nbsp;case&nbsp;analysis&nbsp;on<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> [<span class="id" type="var">Hn</span> | <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;Here,&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;Here,&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#mult_n_O"><span class="id" type="lemma">mult_n_O</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Conversely, to show that a disjunction holds, we need to show that
    one of its sides does. This is done via two tactics, <span class="inlinecode"><span class="id" type="var">left</span></span> and
    <span class="inlinecode"><span class="id" type="var">right</span></span>.  As their names imply, the first one requires
    proving the left side of the disjunction, while the second
    requires proving its right side.  Here is a trivial use... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="or_intro"><span class="id" type="lemma">or_intro</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>, <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#B"><span class="id" type="variable">B</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">left</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
... and a slightly more interesting example requiring both <span class="inlinecode"><span class="id" type="var">left</span></span>
    and <span class="inlinecode"><span class="id" type="var">right</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="zero_or_succ"><span class="id" type="lemma">zero_or_succ</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [|<span class="id" type="var">n</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="var">right</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab161"></a><h4 class="section">Exercise: 1 star (mult_eq_0)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <a name="mult_eq_0"><span class="id" type="lemma">mult_eq_0</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab162"></a><h4 class="section">Exercise: 1 star (or_commut)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="or_commut"><span class="id" type="lemma">or_commut</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>  <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab163"></a><h2 class="section">Falsehood and Negation</h2>

<div class="paragraph"> </div>

 So far, we have mostly been concerned with proving that certain
    things are <i>true</i> &mdash; addition is commutative, appending lists is
    associative, etc.  Of course, we may also be interested in
    <i>negative</i> results, showing that certain propositions are <i>not</i>
    true. In Coq, such negative statements are expressed with the
    negation operator <span class="inlinecode">¬</span>.

<div class="paragraph"> </div>

    To see how negation works, recall the discussion of the <i>principle
    of explosion</i> from the <a href="Tactics.html"><span class="inlineref">Tactics</span></a> chapter; it asserts that, if we
    assume a contradiction, then any other proposition can be derived.
    Following this intuition, we could define <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span> ("not <span class="inlinecode"><span class="id" type="var">P</span></span>") as
    <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>.  Coq actually makes a slightly different
    choice, defining <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span> as <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">False</span></span>, where <span class="inlinecode"><span class="id" type="var">False</span></span> is a
    <i>particular</i> contradictory proposition defined in the standard
    library. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <a name="MyNot"><span class="id" type="module">MyNot</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="MyNot.not"><span class="id" type="definition">not</span></a> (<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>) := <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> "¬ x" := (<a class="idref" href="Logic.html#MyNot.not"><span class="id" type="definition">not</span></a> <span class="id" type="var">x</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#MyNot.not"><span class="id" type="definition">not</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Logic.html#MyNot"><span class="id" type="module">MyNot</span></a>.<br/>

<br/>
</div>

<div class="doc">
Since <span class="inlinecode"><span class="id" type="var">False</span></span> is a contradictory proposition, the principle of
    explosion also applies to it. If we get <span class="inlinecode"><span class="id" type="var">False</span></span> into the proof
    context, we can <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> it to complete any goal: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The Latin <i>ex falso quodlibet</i> means, literally, "from falsehood
    follows whatever you like"; this is another common name for the
    principle of explosion. 
<div class="paragraph"> </div>

<a name="lab164"></a><h4 class="section">Exercise: 2 stars, optional (not_implies_our_not)</h4>
 Show that Coq's definition of negation implies the intuitive one
    mentioned above: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fact</span> <a name="not_implies_our_not"><span class="id" type="lemma">not_implies_our_not</span></a> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;¬ <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&rarr;</span> (<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>), <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

 This is how we use <span class="inlinecode"><span class="id" type="var">not</span></span> to state that <span class="inlinecode">0</span> and <span class="inlinecode">1</span> are different
    elements of <span class="inlinecode"><span class="id" type="var">nat</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="zero_not_one"><span class="id" type="lemma">zero_not_one</span></a> : ~(0 = 1).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Such inequality statements are frequent enough to warrant a
    special notation, <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" type="var">y</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (0 ≠ 1).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="zero_not_one'"><span class="id" type="lemma">zero_not_one'</span></a> : 0 ≠ 1.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It takes a little practice to get used to working with negation in
    Coq.  Even though you can see perfectly well why a statement
    involving negation is true, it can be a little tricky at first to
    get things into the right configuration so that Coq can understand
    it!  Here are proofs of a few familiar facts to get you warmed
    up. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_False"><span class="id" type="lemma">not_False</span></a> :<br/>
&nbsp;&nbsp;¬ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="contradiction_implies_anything"><span class="id" type="lemma">contradiction_implies_anything</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> ¬<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HNA</span>]. <span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">HNA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HNA</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HP</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="double_neg"><span class="id" type="lemma">double_neg</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&rarr;</span> ~~<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab165"></a><h4 class="section">Exercise: 2 stars, advanced, recommended (double_neg_inf)</h4>
 Write an informal proof of <span class="inlinecode"><span class="id" type="var">double_neg</span></span>:

<div class="paragraph"> </div>

   <i>Theorem</i>: <span class="inlinecode"><span class="id" type="var">P</span></span> implies <span class="inlinecode">~~<span class="id" type="var">P</span></span>, for any proposition <span class="inlinecode"><span class="id" type="var">P</span></span>.

<div class="paragraph"> </div>

   <i>Proof</i>:
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab166"></a><h4 class="section">Exercise: 2 stars, recommended (contrapositive)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="contrapositive"><span class="id" type="lemma">contrapositive</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&rarr;</span> (¬<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&rarr;</span> ¬<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab167"></a><h4 class="section">Exercise: 1 star (not_both_true_and_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="not_both_true_and_false"><span class="id" type="lemma">not_both_true_and_false</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;¬ (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> ¬<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab168"></a><h4 class="section">Exercise: 1 star, advanced (informal_not_PNP)</h4>
 Write an informal proof (in English) of the proposition <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span>
    <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span>,</span> <span class="inlinecode">~(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

 Similarly, since inequality involves a negation, it requires a
    little practice to be able to work with it fluently.  Here is one
    useful trick.  If you are trying to prove a goal that is
    nonsensical (e.g., the goal state is <span class="inlinecode"><span class="id" type="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>), apply
    <span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span> to change the goal to <span class="inlinecode"><span class="id" type="var">False</span></span>.  This makes it
    easier to use assumptions of the form <span class="inlinecode">¬<span class="id" type="var">P</span></span> that may be available
    in the context &mdash; in particular, assumptions of the form
    <span class="inlinecode"><span class="id" type="var">x</span>≠<span class="id" type="var">y</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_true_is_false"><span class="id" type="lemma">not_true_is_false</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#b"><span class="id" type="variable">b</span></a> ≠ <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [] <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Since reasoning with <span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span> is quite common, Coq
    provides a built-in tactic, <span class="inlinecode"><span class="id" type="var">exfalso</span></span>, for applying it. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_true_is_false'"><span class="id" type="lemma">not_true_is_false'</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#b"><span class="id" type="variable">b</span></a> ≠ <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [] <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">exfalso</span>. <span class="comment">(*&nbsp;&lt;===&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;true&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab169"></a><h2 class="section">Truth</h2>

<div class="paragraph"> </div>

 Besides <span class="inlinecode"><span class="id" type="var">False</span></span>, Coq's standard library also defines <span class="inlinecode"><span class="id" type="var">True</span></span>, a
    proposition that is trivially true. To prove it, we use the
    predefined constant <span class="inlinecode"><span class="id" type="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">True</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="True_is_true"><span class="id" type="lemma">True_is_true</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Unlike <span class="inlinecode"><span class="id" type="var">False</span></span>, which is used extensively, <span class="inlinecode"><span class="id" type="var">True</span></span> is used quite
    rarely, since it is trivial (and therefore uninteresting) to prove
    as a goal, and it carries no useful information as a hypothesis. 
    But it can be quite useful when defining complex <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>s using
    conditionals or as a parameter to higher-order <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>s.  We will
    see examples of such uses of <span class="inlinecode"><span class="id" type="var">True</span></span> later on. 

<div class="paragraph"> </div>

<a name="lab170"></a><h2 class="section">Logical Equivalence</h2>

<div class="paragraph"> </div>

 The handy "if and only if" connective, which asserts that two
    propositions have the same truth value, is just the conjunction of
    two implications. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <a name="MyIff"><span class="id" type="module">MyIff</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="MyIff.iff"><span class="id" type="definition">iff</span></a> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) := (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&and;</span> (<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>).<br/>

<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">&harr;</span> Q" := (<a class="idref" href="Logic.html#MyIff.iff"><span class="id" type="definition">iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 95, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Logic.html#MyIff"><span class="id" type="module">MyIff</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_sym"><span class="id" type="lemma">iff_sym</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBA</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;-&gt;&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HBA</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;&lt;-&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="not_true_iff_false"><span class="id" type="lemma">not_true_iff_false</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#b"><span class="id" type="variable">b</span></a> ≠ <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;-&gt;&nbsp;*)</span> <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#not_true_is_false"><span class="id" type="lemma">not_true_is_false</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;&lt;-&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab171"></a><h4 class="section">Exercise: 1 star, optional (iff_properties)</h4>
 Using the above proof that <span class="inlinecode"><span style="font-family: arial;">&harr;</span></span> is symmetric (<span class="inlinecode"><span class="id" type="var">iff_sym</span></span>) as
    a guide, prove that it is also reflexive and transitive. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_refl"><span class="id" type="lemma">iff_refl</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_trans"><span class="id" type="lemma">iff_trans</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab172"></a><h4 class="section">Exercise: 3 stars (or_distributes_over_and)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="or_distributes_over_and"><span class="id" type="lemma">or_distributes_over_and</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> (<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>) <span style="font-family: arial;">&harr;</span> (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&and;</span> (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

 Some of Coq's tactics treat <span class="inlinecode"><span class="id" type="var">iff</span></span> statements specially, avoiding
    the need for some low-level proof-state manipulation.  In
    particular, <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> and <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> can be used with <span class="inlinecode"><span class="id" type="var">iff</span></span>
    statements, not just equalities.  To enable this behavior, we need
    to import a special Coq library that allows rewriting with other
    formulas besides equality: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Setoids.Setoid.html#"><span class="id" type="library">Coq.Setoids.Setoid</span></a>.<br/>

<br/>
</div>

<div class="doc">
Here is a simple example demonstrating how these tactics work with
    <span class="inlinecode"><span class="id" type="var">iff</span></span>.  First, let's prove a couple of basic iff equivalences... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="mult_0"><span class="id" type="lemma">mult_0</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#mult_eq_0"><span class="id" type="axiom">mult_eq_0</span></a>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#or_example"><span class="id" type="lemma">or_example</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="or_assoc"><span class="id" type="lemma">or_assoc</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>, <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> (<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>) <span style="font-family: arial;">&harr;</span> (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#R"><span class="id" type="variable">R</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [[<span class="id" type="var">H</span> | <span class="id" type="var">H</span>] | <span class="id" type="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can now use these facts with <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> and <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> to
    give smooth proofs of statements involving equivalences.  Here is
    a ternary version of the previous <span class="inlinecode"><span class="id" type="var">mult_0</span></span> result: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="mult_0_3"><span class="id" type="lemma">mult_0_3</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> * <a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a> = 0 <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#mult_0"><span class="id" type="lemma">mult_0</span></a>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#mult_0"><span class="id" type="lemma">mult_0</span></a>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#or_assoc"><span class="id" type="lemma">or_assoc</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic can also be used with <span class="inlinecode"><span style="font-family: arial;">&harr;</span></span>. When given an
    equivalence as its argument, <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tries to guess which side of
    the equivalence to use. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="apply_iff_example"><span class="id" type="lemma">apply_iff_example</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0 <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#mult_0"><span class="id" type="lemma">mult_0</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab173"></a><h2 class="section">Existential Quantification</h2>

<div class="paragraph"> </div>

 Another important logical connective is <i>existential
    quantification</i>.  To say that there is some <span class="inlinecode"><span class="id" type="var">x</span></span> of type <span class="inlinecode"><span class="id" type="var">T</span></span> such
    that some property <span class="inlinecode"><span class="id" type="var">P</span></span> holds of <span class="inlinecode"><span class="id" type="var">x</span></span>, we write <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span>,</span>
    <span class="inlinecode"><span class="id" type="var">P</span></span>. As with <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>, the type annotation <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> can be omitted if
    Coq is able to infer from the context what the type of <span class="inlinecode"><span class="id" type="var">x</span></span> should
    be. 
<div class="paragraph"> </div>

 To prove a statement of the form <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span>, we must show that
    <span class="inlinecode"><span class="id" type="var">P</span></span> holds for some specific choice of value for <span class="inlinecode"><span class="id" type="var">x</span></span>, known as the
    <i>witness</i> of the existential.  This is done in two steps: First,
    we explicitly tell Coq which witness <span class="inlinecode"><span class="id" type="var">t</span></span> we have in mind by
    invoking the tactic <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span>.  Then we prove that <span class="inlinecode"><span class="id" type="var">P</span></span> holds after
    all occurrences of <span class="inlinecode"><span class="id" type="var">x</span></span> are replaced by <span class="inlinecode"><span class="id" type="var">t</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="four_is_even"><span class="id" type="lemma">four_is_even</span></a> : <span style="font-family: arial;">&exist;</span><span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 4 = <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span>2. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Conversely, if we have an existential hypothesis <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> in
    the context, we can destruct it to obtain a witness <span class="inlinecode"><span class="id" type="var">x</span></span> and a
    hypothesis stating that <span class="inlinecode"><span class="id" type="var">P</span></span> holds of <span class="inlinecode"><span class="id" type="var">x</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="exists_example_2"><span class="id" type="lemma">exists_example_2</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">m</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 4 + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">o</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 2 + <a class="idref" href="Logic.html#o"><span class="id" type="variable">o</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> [<span class="id" type="var">m</span> <span class="id" type="var">Hm</span>]. <span class="comment">(*&nbsp;note&nbsp;implicit&nbsp;<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>&nbsp;here&nbsp;*)</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span>(2 + <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hm</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab174"></a><h4 class="section">Exercise: 1 star (dist_not_exists)</h4>
 Prove that "<span class="inlinecode"><span class="id" type="var">P</span></span> holds for all <span class="inlinecode"><span class="id" type="var">x</span></span>" implies "there is no <span class="inlinecode"><span class="id" type="var">x</span></span> for
    which <span class="inlinecode"><span class="id" type="var">P</span></span> does not hold." 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="dist_not_exists"><span class="id" type="lemma">dist_not_exists</span></a> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>, <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>) <span style="font-family: arial;">&rarr;</span> ¬ (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, ¬ <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab175"></a><h4 class="section">Exercise: 2 stars (dist_exists_or)</h4>
 Prove that existential quantification distributes over
    disjunction. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="dist_exists_or"><span class="id" type="lemma">dist_exists_or</span></a> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>) <span style="font-family: arial;">&harr;</span> (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>) <span style="font-family: arial;">&or;</span> (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab176"></a><h1 class="section">Programming with Propositions</h1>

<div class="paragraph"> </div>

 The logical connectives that we have seen provide a rich
    vocabulary for defining complex propositions from simpler ones.
    To illustrate, let's look at how to express the claim that an
    element <span class="inlinecode"><span class="id" type="var">x</span></span> occurs in a list <span class="inlinecode"><span class="id" type="var">l</span></span>.  Notice that this property has a
    simple recursive structure: 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" type="var">l</span></span> is the empty list, then <span class="inlinecode"><span class="id" type="var">x</span></span> cannot occur on it, so the
      property "<span class="inlinecode"><span class="id" type="var">x</span></span> appears in <span class="inlinecode"><span class="id" type="var">l</span></span>" is simply false.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Otherwise, <span class="inlinecode"><span class="id" type="var">l</span></span> has the form <span class="inlinecode"><span class="id" type="var">x'</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">l'</span></span>.  In this case, <span class="inlinecode"><span class="id" type="var">x</span></span>
      occurs in <span class="inlinecode"><span class="id" type="var">l</span></span> if either it is equal to <span class="inlinecode"><span class="id" type="var">x'</span></span> or it occurs in
      <span class="inlinecode"><span class="id" type="var">l'</span></span>.

<div class="paragraph"> </div>


</li>
</ul>
    We can translate this directly into a straightforward recursive
    function from taking an element and a list and returning a
    proposition: 
</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="In"><span class="id" type="definition">In</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">x</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">x'</span> :: <span class="id" type="var">l'</span> ⇒ <span class="id" type="var">x'</span> = <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
When <span class="inlinecode"><span class="id" type="var">In</span></span> is applied to a concrete list, it expands into a
    concrete sequence of nested disjunctions. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="In_example_1"><span class="id" type="definition">In_example_1</span></a> : <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> 4 [1; 2; 3; 4; 5].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="var">right</span>. <span class="id" type="var">right</span>. <span class="id" type="var">right</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="In_example_2"><span class="id" type="definition">In_example_2</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> [2; 4] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span><span class="id" type="var">n'</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 2 * <a class="idref" href="Logic.html#n'"><span class="id" type="variable">n'</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> [<span class="id" type="var">H</span> | [<span class="id" type="var">H</span> | []]].<br/>
&nbsp;&nbsp;- <span style="font-family: arial;">&exist;</span>1. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span style="font-family: arial;">&exist;</span>2. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
(Notice the use of the empty pattern to discharge the last case
    <i>en passant</i>.) 
<div class="paragraph"> </div>

 We can also prove more generic, higher-level lemmas about <span class="inlinecode"><span class="id" type="var">In</span></span>.

<div class="paragraph"> </div>

    Note, in the next, how <span class="inlinecode"><span class="id" type="var">In</span></span> starts out applied to a variable and
    only gets expanded when we do case analysis on this variable: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="In_map"><span class="id" type="lemma">In_map</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">x</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> (<a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>) (<a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> <a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">x'</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;nil,&nbsp;contradiction&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> [].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;x'&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This way of defining propositions recursively, though convenient
    in some cases, also has some drawbacks.  In particular, it is
    subject to Coq's usual restrictions regarding the definition of
    recursive functions, e.g., the requirement that they be "obviously
    terminating."  In the next chapter, we will see how to define
    propositions <i>inductively</i>, a different technique with its own set
    of strengths and limitations. 
<div class="paragraph"> </div>

<a name="lab177"></a><h4 class="section">Exercise: 2 stars (In_map_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <a name="In_map_iff"><span class="id" type="lemma">In_map_iff</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">y</span> : <a class="idref" href="Logic.html#B"><span class="id" type="variable">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#y"><span class="id" type="variable">y</span></a> (<a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> <a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a>) <span style="font-family: arial;">&harr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> = <a class="idref" href="Logic.html#y"><span class="id" type="variable">y</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab178"></a><h4 class="section">Exercise: 2 stars (in_app_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <a name="in_app_iff"><span class="id" type="lemma">in_app_iff</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> <span class="id" type="var">l</span> <span class="id" type="var">l'</span> (<span class="id" type="var">a</span>:<a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#a"><span class="id" type="variable">a</span></a> (<a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a>++<a class="idref" href="Logic.html#l'"><span class="id" type="variable">l'</span></a>) <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Logic.html#l'"><span class="id" type="variable">l'</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab179"></a><h4 class="section">Exercise: 3 stars (All)</h4>
 Recall that functions returning propositions can be seen as
    <i>properties</i> of their arguments. For instance, if <span class="inlinecode"><span class="id" type="var">P</span></span> has type
    <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, then <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> states that property <span class="inlinecode"><span class="id" type="var">P</span></span> holds of <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

    Drawing inspiration from <span class="inlinecode"><span class="id" type="var">In</span></span>, write a recursive function <span class="inlinecode"><span class="id" type="var">All</span></span>
    stating that some property <span class="inlinecode"><span class="id" type="var">P</span></span> holds of all elements of a list
    <span class="inlinecode"><span class="id" type="var">l</span></span>. To make sure your definition is correct, prove the <span class="inlinecode"><span class="id" type="var">All_In</span></span>
    lemma below.  (Of course, your definition should <i>not</i> just
    restate the left-hand side of <span class="inlinecode"><span class="id" type="var">All_In</span></span>.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="All"><span class="id" type="definition">All</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">P</span> : <a class="idref" href="Logic.html#T"><span class="id" type="variable">T</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#T"><span class="id" type="variable">T</span></a>) : <span class="id" type="keyword">Prop</span> <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;&nbsp;&nbsp;:=&nbsp;_your_definition_&nbsp;.&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="All_In"><span class="id" type="lemma">All_In</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">T</span> (<span class="id" type="var">P</span> : <a class="idref" href="Logic.html#T"><span class="id" type="variable">T</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>) <span style="font-family: arial;">&harr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#All"><span class="id" type="axiom">All</span></a> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab180"></a><h4 class="section">Exercise: 3 stars (combine_odd_even)</h4>
 Complete the definition of the <span class="inlinecode"><span class="id" type="var">combine_odd_even</span></span> function below.
    It takes as arguments two properties of numbers, <span class="inlinecode"><span class="id" type="var">Podd</span></span> and
    <span class="inlinecode"><span class="id" type="var">Peven</span></span>, and it should return a property <span class="inlinecode"><span class="id" type="var">P</span></span> such that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> is
    equivalent to <span class="inlinecode"><span class="id" type="var">Podd</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> when <span class="inlinecode"><span class="id" type="var">n</span></span> is odd and equivalent to <span class="inlinecode"><span class="id" type="var">Peven</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
    otherwise. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="combine_odd_even"><span class="id" type="definition">combine_odd_even</span></a> (<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;&nbsp;&nbsp;:=&nbsp;_your_definition_&nbsp;.&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
To test your definition, prove the following facts: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="combine_odd_even_intro"><span class="id" type="lemma">combine_odd_even_intro</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Podd"><span class="id" type="variable">Podd</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Peven"><span class="id" type="variable">Peven</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#combine_odd_even"><span class="id" type="axiom">combine_odd_even</span></a> <a class="idref" href="Logic.html#Podd"><span class="id" type="variable">Podd</span></a> <a class="idref" href="Logic.html#Peven"><span class="id" type="variable">Peven</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="combine_odd_even_elim_odd"><span class="id" type="lemma">combine_odd_even_elim_odd</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#combine_odd_even"><span class="id" type="axiom">combine_odd_even</span></a> <a class="idref" href="Logic.html#Podd"><span class="id" type="variable">Podd</span></a> <a class="idref" href="Logic.html#Peven"><span class="id" type="variable">Peven</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#Podd"><span class="id" type="variable">Podd</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="combine_odd_even_elim_even"><span class="id" type="lemma">combine_odd_even_elim_even</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#combine_odd_even"><span class="id" type="axiom">combine_odd_even</span></a> <a class="idref" href="Logic.html#Podd"><span class="id" type="variable">Podd</span></a> <a class="idref" href="Logic.html#Peven"><span class="id" type="variable">Peven</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#Peven"><span class="id" type="variable">Peven</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab181"></a><h1 class="section">Applying Theorems to Arguments</h1>

<div class="paragraph"> </div>

 One feature of Coq that distinguishes it from many other proof
    assistants is that it treats <i>proofs</i> as first-class objects.

<div class="paragraph"> </div>

    There is a great deal to be said about this, but it is not
    necessary to understand it in detail in order to use Coq.  This
    section gives just a taste, while a deeper exploration can be
    found in the optional chapters <span class="inlinecode"><span class="id" type="var">ProofObjects</span></span> and
    <span class="inlinecode"><span class="id" type="var">IndPrinciples</span></span>. 
<div class="paragraph"> </div>

 We have seen that we can use the <span class="inlinecode"><span class="id" type="keyword">Check</span></span> command to ask Coq to
    print the type of an expression.  We can also use <span class="inlinecode"><span class="id" type="keyword">Check</span></span> to ask
    what theorem a particular identifier refers to. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Coq prints the <i>statement</i> of the <span class="inlinecode"><span class="id" type="var">plus_comm</span></span> theorem in the same
    way that it prints the <i>type</i> of any term that we ask it to
    <span class="inlinecode"><span class="id" type="keyword">Check</span></span>.  Why?

<div class="paragraph"> </div>

    The reason is that the identifier <span class="inlinecode"><span class="id" type="var">plus_comm</span></span> actually refers to a
    <i>proof object</i> &mdash; a data structure that represents a logical
    derivation establishing of the truth of the statement <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>
    <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>.  The type of this object <i>is</i> the statement
    of the theorem that it is a proof of. 
<div class="paragraph"> </div>

 Intuitively, this makes sense because the statement of a theorem
    tells us what we can use that theorem for, just as the type of a
    computational object tells us what we can do with that object &mdash;
    e.g., if we have a term of type <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>, we can give
    it two <span class="inlinecode"><span class="id" type="var">nat</span></span>s as arguments and get a <span class="inlinecode"><span class="id" type="var">nat</span></span> back.  Similarly, if we
    have an object of type <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span> and we provide it
    an "argument" of type <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>, we can derive <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span>. 
<div class="paragraph"> </div>

 Operationally, this analogy goes even further: by applying a
    theorem, as if it were a function, to hypotheses with matching
    types, we can specialize its result without having to resort to
    intermediate assertions.  For example, suppose we wanted to prove
    the following result: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="plus_comm3"><span class="id" type="lemma">plus_comm3</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + (<a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a>) = (<a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a>) + <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>

<br/>
</div>

<div class="doc">
It appears at first sight that we ought to be able to prove this
    by rewriting with <span class="inlinecode"><span class="id" type="var">plus_comm</span></span> twice to make the two sides match.
    The problem, however, is that the second <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> will undo the
    effect of the first. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;back&nbsp;where&nbsp;we&nbsp;started...&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
One simple way of fixing this problem, using only tools that we
    already know, is to use <span class="inlinecode"><span class="id" type="tactic">assert</span></span> to derive a specialized version
    of <span class="inlinecode"><span class="id" type="var">plus_comm</span></span> that can be used to rewrite exactly where we
    want. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="plus_comm3_take2"><span class="id" type="lemma">plus_comm3_take2</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + (<a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a>) = (<a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a>) + <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="var">m</span> + <span class="id" type="var">p</span> = <span class="id" type="var">p</span> + <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">rewrite</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>. <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A more elegant alternative is to apply <span class="inlinecode"><span class="id" type="var">plus_comm</span></span> directly to the
    arguments we want to instantiate it with, in much the same way as
    we apply a polymorphic function to a type argument. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="plus_comm3_take3"><span class="id" type="lemma">plus_comm3_take3</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> + (<a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a>) = (<a class="idref" href="Logic.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a>) + <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a> <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
You can "use theorems as functions" in this way with almost all
    tactics that take a theorem name as an argument.  Note also that
    theorem application uses the same inference mechanisms as function
    application; thus, it is possible, for example, to supply
    wildcards as arguments to be inferred, or to declare some
    hypotheses to a theorem as implicit by default.  These features
    are illustrated in the proof below. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="lemma_application_ex"><span class="id" type="definition">lemma_application_ex</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>{<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>} {<span class="id" type="var">ns</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> * 0) <a class="idref" href="Logic.html#ns"><span class="id" type="variable">ns</span></a>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">ns</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<a class="idref" href="Logic.html#proj1"><span class="id" type="lemma">proj1</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<a class="idref" href="Logic.html#In_map_iff"><span class="id" type="axiom">In_map_iff</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [<span class="id" type="var">m</span> [<span class="id" type="var">Hm</span> <span class="id" type="var">_</span>]].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Induction.html#mult_0_r"><span class="id" type="axiom">mult_0_r</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Hm</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">Hm</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We will see many more examples of the idioms from this section in
    later chapters. 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab182"></a><h1 class="section">Coq vs. Set Theory</h1>

<div class="paragraph"> </div>

 Coq's logical core, the <i>Calculus of Inductive Constructions</i>,
    differs in some important ways from other formal systems that are
    used by mathematicians for writing down precise and rigorous
    proofs.  For example, in the most popular foundation for
    mainstream paper-and-pencil mathematics, Zermelo-Fraenkel Set
    Theory (ZFC), a mathematical object can potentially be a member of
    many different sets; a term in Coq's logic, on the other hand, is
    a member of at most one type.  This difference often leads to
    slightly different ways of capturing informal mathematical
    concepts, but these are, by and large, quite natural and easy to
    work with.  For example, instead of saying that a natural number
    <span class="inlinecode"><span class="id" type="var">n</span></span> belongs to the set of even numbers, we would say in Coq that
    <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> holds, where <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> is a property describing
    even numbers.

<div class="paragraph"> </div>

    However, there are some cases where translating standard
    mathematical reasoning into Coq can be either cumbersome or
    sometimes even impossible, unless we enrich the core logic with
    additional axioms.  We conclude this chapter with a brief
    discussion of some of the most significant differences between the
    two worlds. 
<div class="paragraph"> </div>

<a name="lab183"></a><h2 class="section">Functional Extensionality</h2>

<div class="paragraph"> </div>

 The equality assertions that we have seen so far mostly have
    concerned elements of inductive types (<span class="inlinecode"><span class="id" type="var">nat</span></span>, <span class="inlinecode"><span class="id" type="var">bool</span></span>, etc.).  But
    since Coq's equality operator is polymorphic, these are not the
    only possibilities &mdash; in particular, we can write propositions
    claiming that two <i>functions</i> are equal to each other: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="function_equality_ex<sub>1</sub>"><span class="id" type="definition">function_equality_ex<sub>1</sub></span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus"><span class="id" type="abbreviation">plus</span></a> 3 = <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus"><span class="id" type="abbreviation">plus</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> 4).<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
In common mathematical practice, two functions <span class="inlinecode"><span class="id" type="var">f</span></span> and <span class="inlinecode"><span class="id" type="var">g</span></span> are
    considered equal if they produce the same outputs:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>,&nbsp;<span class="id" type="var">f</span>&nbsp;<span class="id" type="var">x</span>&nbsp;=&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">x</span>)&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">f</span>&nbsp;=&nbsp;<span class="id" type="var">g</span>
<div class="paragraph"> </div>

</div>
    This is known as the principle of <i>functional extensionality</i>.

<div class="paragraph"> </div>

    Informally speaking, an "extensional property" is one that
    pertains to an object's observable behavior.  Thus, functional
    extensionality simply means that a function's identity is
    completely determined by what we can observe from it &mdash; i.e., in
    Coq terms, the results we obtain after applying it.

<div class="paragraph"> </div>

    Functional extensionality is not part of Coq's basic axioms.  This
    means that some "reasonable" propositions are not provable. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="function_equality_ex<sub>2</sub>"><span class="id" type="definition">function_equality_ex<sub>2</sub></span></a> :<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus"><span class="id" type="abbreviation">plus</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> 1) = (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus"><span class="id" type="abbreviation">plus</span></a> 1 <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Stuck&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
However, we can add functional extensionality to Coq's core logic
    using the <span class="inlinecode"><span class="id" type="keyword">Axiom</span></span> command. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Axiom</span> <a name="functional_extensionality"><span class="id" type="axiom">functional_extensionality</span></a> : <span style="font-family: arial;">&forall;</span>{<span class="id" type="var">X</span> <span class="id" type="var">Y</span>: <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" type="var">f</span> <span class="id" type="var">g</span> : <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#Y"><span class="id" type="variable">Y</span></a>},<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">x</span>:<a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a>), <a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> = <a class="idref" href="Logic.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#f"><span class="id" type="variable">f</span></a> = <a class="idref" href="Logic.html#g"><span class="id" type="variable">g</span></a>.<br/>

<br/>
</div>

<div class="doc">
Using <span class="inlinecode"><span class="id" type="keyword">Axiom</span></span> has the same effect as stating a theorem and
    skipping its proof using <span class="inlinecode"><span class="id" type="var">Admitted</span></span>, but it alerts the reader that
    this isn't just something we're going to come back and fill in
    later!

<div class="paragraph"> </div>

    We can now invoke functional extensionality in proofs: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="function_equality_ex<sub>2</sub>"><span class="id" type="definition">function_equality_ex<sub>2</sub></span></a> :<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus"><span class="id" type="abbreviation">plus</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> 1) = (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus"><span class="id" type="abbreviation">plus</span></a> 1 <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#functional_extensionality"><span class="id" type="axiom">functional_extensionality</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Naturally, we must be careful when adding new axioms into Coq's
    logic, as they may render it <i>inconsistent</i> &mdash; that is, they may
    make it possible to prove every proposition, including <span class="inlinecode"><span class="id" type="var">False</span></span>!

<div class="paragraph"> </div>

    Unfortunately, there is no simple way of telling whether an axiom
    is safe to add: hard work is generally required to establish the
    consistency of any particular combination of axioms.

<div class="paragraph"> </div>

    However, it is known that adding functional extensionality, in
    particular, <i>is</i> consistent.

<div class="paragraph"> </div>

    To check whether a particular proof relies on any additional
    axioms, use the <span class="inlinecode"><span class="id" type="keyword">Print</span></span> <span class="inlinecode"><span class="id" type="var">Assumptions</span></span> command.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">Assumptions</span> <a class="idref" href="Logic.html#function_equality_ex<sub>2</sub>"><span class="id" type="definition">function_equality_ex<sub>2</sub></span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Axioms:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;functional_extensionality&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(X&nbsp;Y&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;g&nbsp;:&nbsp;X&nbsp;-&gt;&nbsp;Y),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;X,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x)&nbsp;-&gt;&nbsp;f&nbsp;=&nbsp;g&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab184"></a><h4 class="section">Exercise: 4 stars (tr_rev)</h4>
 One problem with the definition of the list-reversing function
    <span class="inlinecode"><span class="id" type="var">rev</span></span> that we have is that it performs a call to <span class="inlinecode"><span class="id" type="var">app</span></span> on each
    step; running <span class="inlinecode"><span class="id" type="var">app</span></span> takes time asymptotically linear in the size
    of the list, which means that <span class="inlinecode"><span class="id" type="var">rev</span></span> has quadratic running time.
    We can improve this with the following definition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="rev_append"><span class="id" type="definition">rev_append</span></a> {<span class="id" type="var">X</span>} (<span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Logic.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <a class="idref" href="Logic.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span> :: <span class="id" type="var">l<sub>1</sub>'</span> ⇒ <a class="idref" href="Logic.html#rev_append"><span class="id" type="definition">rev_append</span></a> <span class="id" type="var">l<sub>1</sub>'</span> (<span class="id" type="var">x</span> :: <a class="idref" href="Logic.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="tr_rev"><span class="id" type="definition">tr_rev</span></a> {<span class="id" type="var">X</span>} (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#rev_append"><span class="id" type="definition">rev_append</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a> [].<br/>

<br/>
</div>

<div class="doc">
This version is said to be <i>tail-recursive</i>, because the recursive
    call to the function is the last operation that needs to be
    performed (i.e., we don't have to execute <span class="inlinecode">++</span> after the recursive
    call); a decent compiler will generate very efficient code in this
    case.  Prove that the two definitions are indeed equivalent. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="tr_rev_correct"><span class="id" type="lemma">tr_rev_correct</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">X</span>, @<a class="idref" href="Logic.html#tr_rev"><span class="id" type="definition">tr_rev</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> = @<a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab185"></a><h2 class="section">Propositions and Booleans</h2>

<div class="paragraph"> </div>

 We've seen two different ways of encoding logical facts in Coq:
    with <i>booleans</i> (of type <span class="inlinecode"><span class="id" type="var">bool</span></span>), and with <i>propositions</i> (of type
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>).

<div class="paragraph"> </div>

    For instance, to claim that a number <span class="inlinecode"><span class="id" type="var">n</span></span> is even, we can say
    either

<div class="paragraph"> </div>

<ul class="doclist">
<li> (1) that <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> returns <span class="inlinecode"><span class="id" type="var">true</span></span>, or

</li>
<li> (2) that there exists some <span class="inlinecode"><span class="id" type="var">k</span></span> such that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>.
             Indeed, these two notions of evenness are equivalent, as
             can easily be shown with a couple of auxiliary lemmas.

</li>
</ul>

<div class="paragraph"> </div>

    We often say that the boolean <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <i>reflects</i> the proposition
    <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="evenb_double"><span class="id" type="lemma">evenb_double</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">k</span>, <a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> (<a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="Logic.html#k"><span class="id" type="variable">k</span></a>) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">k</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">k</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">k'</span> <span class="id" type="var">IHk'</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHk'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab186"></a><h4 class="section">Exercise: 3 stars (evenb_double_conv)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="evenb_double_conv"><span class="id" type="lemma">evenb_double_conv</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="Logic.html#k"><span class="id" type="variable">k</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="Logic.html#k"><span class="id" type="variable">k</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Hint:&nbsp;Use&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">evenb_S</span></span>&nbsp;lemma&nbsp;from&nbsp;<span class="inlinecode"><span class="id" type="var">Induction.v</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="even_bool_prop"><span class="id" type="lemma">even_bool_prop</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="Logic.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> (<a class="idref" href="Logic.html#evenb_double_conv"><span class="id" type="axiom">evenb_double_conv</span></a> <span class="id" type="var">n</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">k</span> <span class="id" type="var">Hk</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">k</span> <span class="id" type="var">Hk</span>]. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#evenb_double"><span class="id" type="lemma">evenb_double</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, to state that two numbers <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span> are equal, we can
    say either (1) that <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> returns <span class="inlinecode"><span class="id" type="var">true</span></span> or (2) that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">m</span></span>.  These two notions are equivalent. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_true_iff"><span class="id" type="lemma">beq_nat_true_iff</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="Logic.html#n<sub>1</sub>"><span class="id" type="variable">n<sub>1</sub></span></a> <a class="idref" href="Logic.html#n<sub>2</sub>"><span class="id" type="variable">n<sub>2</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#n<sub>1</sub>"><span class="id" type="variable">n<sub>1</sub></span></a> = <a class="idref" href="Logic.html#n<sub>2</sub>"><span class="id" type="variable">n<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="Tactics.html#beq_nat_true"><span class="id" type="axiom">beq_nat_true</span></a>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <a class="idref" href="Induction.html#beq_nat_refl"><span class="id" type="axiom">beq_nat_refl</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
However, while the boolean and propositional formulations of a
    claim are equivalent from a purely logical perspective, they need
    not be equivalent <i>operationally</i>.  Equality provides an extreme
    example: knowing that <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span> is generally of little
    direct help in the middle of a proof involving <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>;
    however, if we convert the statement to the equivalent form <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">m</span></span>, we can rewrite with it.

<div class="paragraph"> </div>

    The case of even numbers is also interesting.  Recall that,
    when proving the backwards direction of <span class="inlinecode"><span class="id" type="var">even_bool_prop</span></span> (i.e.,
    <span class="inlinecode"><span class="id" type="var">evenb_double</span></span>, going from the propositional to the boolean
    claim), we used a simple induction on <span class="inlinecode"><span class="id" type="var">k</span></span>.  On the other hand, the
    converse (the <span class="inlinecode"><span class="id" type="var">evenb_double_conv</span></span> exercise) required a clever
    generalization, since we can't directly prove <span class="inlinecode">(<span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span>)</span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>.

<div class="paragraph"> </div>

    For these examples, the propositional claims are more useful than
    their boolean counterparts, but this is not always the case.  For
    instance, we cannot test whether a general proposition is true or
    not in a function definition; as a consequence, the following code
    fragment is rejected: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Fail</span> <span class="id" type="keyword">Definition</span> <a name="is_even_prime"><span class="id" type="definition">is_even_prime</span></a> <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = 2 <span class="id" type="keyword">then</span> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
</div>

<div class="doc">
Coq complains that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> has type <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, while it expects an
    elements of <span class="inlinecode"><span class="id" type="var">bool</span></span> (or some other inductive type with two
    elements).  The reason for this error message has to do with the
    <i>computational</i> nature of Coq's core language, which is designed
    so that every function that it can express is computable and
    total.  One reason for this is to allow the extraction of
    executable programs from Coq developments.  As a consequence,
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> in Coq does <i>not</i> have a universal case analysis operation
    telling whether any given proposition is true or false, since such
    an operation would allow us to write non-computable functions.

<div class="paragraph"> </div>

    Although general non-computable properties cannot be phrased as
    boolean computations, it is worth noting that even many
    <i>computable</i> properties are easier to express using <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> than
    <span class="inlinecode"><span class="id" type="var">bool</span></span>, since recursive function definitions are subject to
    significant restrictions in Coq.  For instance, the next chapter
    shows how to define the property that a regular expression matches
    a given string using <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>.  Doing the same with <span class="inlinecode"><span class="id" type="var">bool</span></span> would
    amount to writing a regular expression matcher, which would be
    more complicated, harder to understand, and harder to reason
    about.

<div class="paragraph"> </div>

    Conversely, an important side benefit of stating facts using
    booleans is enabling some proof automation through computation
    with Coq terms, a technique known as <i>proof by
    reflection</i>.  Consider the following statement: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="even_1000"><span class="id" type="definition">even_1000</span></a> : <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, 1000 = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="Logic.html#k"><span class="id" type="variable">k</span></a>.<br/>

<br/>
</div>

<div class="doc">
The most direct proof of this fact is to give the value of <span class="inlinecode"><span class="id" type="var">k</span></span>
    explicitly. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>. <span style="font-family: arial;">&exist;</span>500. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
On the other hand, the proof of the corresponding boolean
    statement is even simpler: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="even_1000'"><span class="id" type="definition">even_1000'</span></a> : <a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> 1000 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
What is interesting is that, since the two notions are equivalent,
    we can use the boolean formulation to prove the other one without
    mentioning the value 500 explicitly: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="even_1000''"><span class="id" type="definition">even_1000''</span></a> : <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, 1000 = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="Logic.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#even_bool_prop"><span class="id" type="lemma">even_bool_prop</span></a>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Although we haven't gained much in terms of proof size in this
    case, larger proofs can often be made considerably simpler by the
    use of reflection.  As an extreme example, the Coq proof of the
    famous <i>4-color theorem</i> uses reflection to reduce the analysis of
    hundreds of different cases to a boolean computation.  We won't
    cover reflection in great detail, but it serves as a good example
    showing the complementary strengths of booleans and general
    propositions. 
<div class="paragraph"> </div>

<a name="lab187"></a><h4 class="section">Exercise: 2 stars (logical_connectives)</h4>
 The following lemmas relate the propositional connectives studied
    in this chapter to the corresponding boolean operations. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="andb_true_iff"><span class="id" type="lemma">andb_true_iff</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b<sub>1</sub></span> <span class="id" type="var">b<sub>2</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#b<sub>1</sub>"><span class="id" type="variable">b<sub>1</sub></span></a> &amp;&amp; <a class="idref" href="Logic.html#b<sub>2</sub>"><span class="id" type="variable">b<sub>2</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#b<sub>1</sub>"><span class="id" type="variable">b<sub>1</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&and;</span> <a class="idref" href="Logic.html#b<sub>2</sub>"><span class="id" type="variable">b<sub>2</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="orb_true_iff"><span class="id" type="lemma">orb_true_iff</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b<sub>1</sub></span> <span class="id" type="var">b<sub>2</sub></span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#b<sub>1</sub>"><span class="id" type="variable">b<sub>1</sub></span></a> || <a class="idref" href="Logic.html#b<sub>2</sub>"><span class="id" type="variable">b<sub>2</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#b<sub>1</sub>"><span class="id" type="variable">b<sub>1</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#b<sub>2</sub>"><span class="id" type="variable">b<sub>2</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab188"></a><h4 class="section">Exercise: 1 star (beq_nat_false_iff)</h4>
 The following theorem is an alternate "negative" formulation of
    <span class="inlinecode"><span class="id" type="var">beq_nat_true_iff</span></span> that is more convenient in certain
    situations (we'll see examples in later chapters). 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_false_iff"><span class="id" type="lemma">beq_nat_false_iff</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Logic.html#y"><span class="id" type="variable">y</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> ≠ <a class="idref" href="Logic.html#y"><span class="id" type="variable">y</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab189"></a><h4 class="section">Exercise: 3 stars (beq_list)</h4>
 Given a boolean operator <span class="inlinecode"><span class="id" type="var">beq</span></span> for testing equality of elements of
    some type <span class="inlinecode"><span class="id" type="var">A</span></span>, we can define a function <span class="inlinecode"><span class="id" type="var">beq_list</span></span> <span class="inlinecode"><span class="id" type="var">beq</span></span> for testing
    equality of lists with elements in <span class="inlinecode"><span class="id" type="var">A</span></span>.  Complete the definition
    of the <span class="inlinecode"><span class="id" type="var">beq_list</span></span> function below.  To make sure that your
    definition is correct, prove the lemma <span class="inlinecode"><span class="id" type="var">beq_list_true_iff</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="beq_list"><span class="id" type="definition">beq_list</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">beq</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;&nbsp;&nbsp;:=&nbsp;_your_definition_&nbsp;.&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="beq_list_true_iff"><span class="id" type="lemma">beq_list_true_iff</span></a> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> (<span class="id" type="var">beq</span> : <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#A"><span class="id" type="variable">A</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span>, <a class="idref" href="Logic.html#beq"><span class="id" type="variable">beq</span></a> <a class="idref" href="Logic.html#a<sub>1</sub>"><span class="id" type="variable">a<sub>1</sub></span></a> <a class="idref" href="Logic.html#a<sub>2</sub>"><span class="id" type="variable">a<sub>2</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#a<sub>1</sub>"><span class="id" type="variable">a<sub>1</sub></span></a> = <a class="idref" href="Logic.html#a<sub>2</sub>"><span class="id" type="variable">a<sub>2</sub></span></a>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span>, <a class="idref" href="Logic.html#beq_list"><span class="id" type="axiom">beq_list</span></a> <a class="idref" href="Logic.html#beq"><span class="id" type="variable">beq</span></a> <a class="idref" href="Logic.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> <a class="idref" href="Logic.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> = <a class="idref" href="Logic.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab190"></a><h4 class="section">Exercise: 2 stars, recommended (All_forallb)</h4>
 Recall the function <span class="inlinecode"><span class="id" type="var">forallb</span></span>, from the exercise
    <span class="inlinecode"><span class="id" type="var">forall_exists_challenge</span></span> in chapter <a href="Tactics.html"><span class="inlineref">Tactics</span></a>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="forallb"><span class="id" type="definition">forallb</span></a> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">test</span> : <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span> :: <span class="id" type="var">l'</span> ⇒ <a class="idref" href="Basics.html#andb"><span class="id" type="definition">andb</span></a> (<a class="idref" href="Logic.html#test"><span class="id" type="variable">test</span></a> <span class="id" type="var">x</span>) (<a class="idref" href="Logic.html#forallb"><span class="id" type="definition">forallb</span></a> <a class="idref" href="Logic.html#test"><span class="id" type="variable">test</span></a> <span class="id" type="var">l'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Prove the theorem below, which relates <span class="inlinecode"><span class="id" type="var">forallb</span></span> to the <span class="inlinecode"><span class="id" type="var">All</span></span>
    property of the above exercise. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="forallb_true_iff"><span class="id" type="lemma">forallb_true_iff</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">X</span> <span class="id" type="var">test</span> (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a>),<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#forallb"><span class="id" type="definition">forallb</span></a> <a class="idref" href="Logic.html#test"><span class="id" type="variable">test</span></a> <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#All"><span class="id" type="axiom">All</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="Logic.html#test"><span class="id" type="variable">test</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) <a class="idref" href="Logic.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Are there any important properties of the function <span class="inlinecode"><span class="id" type="var">forallb</span></span> which
    are not captured by this specification? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab191"></a><h2 class="section">Classical vs. Constructive Logic</h2>

<div class="paragraph"> </div>

 We have seen that it is not possible to test whether or not a
    proposition <span class="inlinecode"><span class="id" type="var">P</span></span> holds while defining a Coq function.  You may be
    surprised to learn that a similar restriction applies to <i>proofs</i>!
    In other words, the following intuitive reasoning principle is not
    derivable in Coq: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="excluded_middle"><span class="id" type="definition">excluded_middle</span></a> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> ¬ <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
To understand operationally why this is the case, recall
    that, to prove a statement of the form <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>, we use the <span class="inlinecode"><span class="id" type="var">left</span></span>
    and <span class="inlinecode"><span class="id" type="var">right</span></span> tactics, which effectively require knowing which side
    of the disjunction holds.  But the universally quantified <span class="inlinecode"><span class="id" type="var">P</span></span> in
    <span class="inlinecode"><span class="id" type="var">excluded_middle</span></span> is an <i>arbitrary</i> proposition, which we know
    nothing about.  We don't have enough information to choose which
    of <span class="inlinecode"><span class="id" type="var">left</span></span> or <span class="inlinecode"><span class="id" type="var">right</span></span> to apply, just as Coq doesn't have enough
    information to mechanically decide whether <span class="inlinecode"><span class="id" type="var">P</span></span> holds or not inside
    a function. 
<div class="paragraph"> </div>

 However, if we happen to know that <span class="inlinecode"><span class="id" type="var">P</span></span> is reflected in some
    boolean term <span class="inlinecode"><span class="id" type="var">b</span></span>, then knowing whether it holds or not is trivial:
    we just have to check the value of <span class="inlinecode"><span class="id" type="var">b</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="restricted_excluded_middle"><span class="id" type="lemma">restricted_excluded_middle</span></a> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Logic.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> ¬ <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> [] <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="var">left</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="var">right</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In particular, the excluded middle is valid for equations <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>,
    between natural numbers <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="restricted_excluded_middle_eq"><span class="id" type="lemma">restricted_excluded_middle_eq</span></a> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#n"><span class="id" type="variable">n</span></a> ≠ <a class="idref" href="Logic.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="Logic.html#restricted_excluded_middle"><span class="id" type="lemma">restricted_excluded_middle</span></a> (<span class="id" type="var">n</span> = <span class="id" type="var">m</span>) (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span>)).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#beq_nat_true_iff"><span class="id" type="lemma">beq_nat_true_iff</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It may seem strange that the general excluded middle is not
    available by default in Coq; after all, any given claim must be
    either true or false.  Nonetheless, there is an advantage in not
    assuming the excluded middle: statements in Coq can make stronger
    claims than the analogous statements in standard mathematics.
    Notably, if there is a Coq proof of <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>, it is
    possible to explicitly exhibit a value of <span class="inlinecode"><span class="id" type="var">x</span></span> for which we can
    prove <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> &mdash; in other words, every proof of existence is
    necessarily <i>constructive</i>. 
<div class="paragraph"> </div>

 Logics like Coq's, which do not assume the excluded middle, are
    referred to as <i>constructive logics</i>.

<div class="paragraph"> </div>

    More conventional logical systems such as ZFC, in which the
    excluded middle does hold for arbitrary propositions, are referred
    to as <i>classical</i>. 
<div class="paragraph"> </div>

 The following example illustrates why assuming the excluded middle
    may lead to non-constructive proofs: 

<div class="paragraph"> </div>

    <i>Claim</i>: There exist irrational numbers <span class="inlinecode"><span class="id" type="var">a</span></span> and <span class="inlinecode"><span class="id" type="var">b</span></span> such that <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">^</span>
    <span class="inlinecode"><span class="id" type="var">b</span></span> is rational.

<div class="paragraph"> </div>

    <i>Proof</i>: It is not difficult to show that <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> is irrational.
    If <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> is rational, it suffices to take <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> and we are done.  Otherwise, <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> is
    irrational.  In this case, we can take <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> and
    <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>, since <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">(<span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span>
    <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>.  <font size=-2 color="rgb(80%,80%,100%)">&#9744;</font>

<div class="paragraph"> </div>

    Do you see what happened here?  We used the excluded middle to
    consider separately the cases where <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> is rational
    and where it is not, without knowing which one actually holds!
    Because of that, we wind up knowing that such <span class="inlinecode"><span class="id" type="var">a</span></span> and <span class="inlinecode"><span class="id" type="var">b</span></span> exist
    but we cannot determine what their actual values are (at least,
    using this line of argument).

<div class="paragraph"> </div>

    As useful as constructive logic is, it does have its limitations:
    There are many statements that can easily be proven in classical
    logic but that have much more complicated constructive proofs, and
    there are some that are known to have no constructive proof at
    all!  Fortunately, like functional extensionality, the excluded
    middle is known to be compatible with Coq's logic, allowing us to
    add it safely as an axiom.  However, we will not need to do so in
    this book: the results that we cover can be developed entirely
    within constructive logic at negligible extra cost.

<div class="paragraph"> </div>

    It takes some practice to understand which proof techniques must
    be avoided in constructive reasoning, but arguments by
    contradiction, in particular, are infamous for leading to
    non-constructive proofs.  Here's a typical example: suppose that
    we want to show that there exists <span class="inlinecode"><span class="id" type="var">x</span></span> with some property <span class="inlinecode"><span class="id" type="var">P</span></span>,
    i.e., such that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>.  We start by assuming that our conclusion
    is false; that is, <span class="inlinecode">¬</span> <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>. From this premise, it is not
    hard to derive <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>.  If we manage to show that this
    intermediate fact results in a contradiction, we arrive at an
    existence proof without ever exhibiting a value of <span class="inlinecode"><span class="id" type="var">x</span></span> for which
    <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> holds!

<div class="paragraph"> </div>

    The technical flaw here, from a constructive standpoint, is that
    we claimed to prove <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> using a proof of
    <span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span>)</span>.  Allowing ourselves to remove double
    negations from arbitrary statements is equivalent to assuming the
    excluded middle, as shown in one of the exercises below.  Thus,
    this line of reasoning cannot be encoded in Coq without assuming
    additional axioms. 
<div class="paragraph"> </div>

<a name="lab192"></a><h4 class="section">Exercise: 3 stars (excluded_middle_irrefutable)</h4>
 The consistency of Coq with the general excluded middle axiom
    requires complicated reasoning that cannot be carried out within
    Coq itself.  However, the following theorem implies that it is
    always safe to assume a decidability axiom (i.e., an instance of
    excluded middle) for any <i>particular</i> Prop <span class="inlinecode"><span class="id" type="var">P</span></span>.  Why? Because we
    cannot prove the negation of such an axiom; if we could, we would
    have both <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span> and <span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span>, a contradiction. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="excluded_middle_irrefutable"><span class="id" type="lemma">excluded_middle_irrefutable</span></a>:  <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;¬ ¬ (<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&or;</span> ¬ <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab193"></a><h4 class="section">Exercise: 3 stars, advanced (not_exists_dist)</h4>
 It is a theorem of classical logic that the following two
    assertions are equivalent:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;¬&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>,&nbsp;¬&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">x</span>
<div class="paragraph"> </div>

</div>
    The <span class="inlinecode"><span class="id" type="var">dist_not_exists</span></span> theorem above proves one side of this
    equivalence. Interestingly, the other direction cannot be proved
    in constructive logic. Your job is to show that it is implied by
    the excluded middle. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_exists_dist"><span class="id" type="lemma">not_exists_dist</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#excluded_middle"><span class="id" type="definition">excluded_middle</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <a class="idref" href="Logic.html#X"><span class="id" type="variable">X</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;¬ (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, ¬ <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>) <span style="font-family: arial;">&rarr;</span> (<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>, <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#x"><span class="id" type="variable">x</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab194"></a><h4 class="section">Exercise: 5 stars, optional (classical_axioms)</h4>
 For those who like a challenge, here is an exercise taken from the
    Coq'Art book by Bertot and Casteran (p. 123).  Each of the
    following four statements, together with <span class="inlinecode"><span class="id" type="var">excluded_middle</span></span>, can be
    considered as characterizing classical logic.  We can't prove any
    of them in Coq, but we can consistently add any one of them as an
    axiom if we wish to work in classical logic.

<div class="paragraph"> </div>

    Prove that all five propositions (these four plus
    <span class="inlinecode"><span class="id" type="var">excluded_middle</span></span>) are equivalent. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="peirce"><span class="id" type="definition">peirce</span></a> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>: <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;((<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a><span style="font-family: arial;">&rarr;</span><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>)<span style="font-family: arial;">&rarr;</span><a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>)<span style="font-family: arial;">&rarr;</span><a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="double_negation_elimination"><span class="id" type="definition">double_negation_elimination</span></a> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~~<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="de_morgan_not_and_not"><span class="id" type="definition">de_morgan_not_and_not</span></a> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~(~<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a> <span style="font-family: arial;">&and;</span> ¬<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a><span style="font-family: arial;">&or;</span><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="implies_to_or"><span class="id" type="definition">implies_to_or</span></a> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a><span style="font-family: arial;">&rarr;</span><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>) <span style="font-family: arial;">&rarr;</span> (¬<a class="idref" href="Logic.html#P"><span class="id" type="variable">P</span></a><span style="font-family: arial;">&or;</span><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>).<br/>

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2 color="rgb(80%,80%,100%)">&#9744;</font> 
<div class="paragraph"> </div>

  
</div>
<div class="code code-tight">
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>